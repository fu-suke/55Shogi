# やったこと
- 将棋GUI探し
  - petit shogi

- 勉強
  - USIプロトコル
  - C++
  - MCTSの本

# 実装

- 実装
  - USIプロトコル動作チェック
  - Bitboard
    - 「すぐ動くもの」だけを考えるならこのようなデータ構造にする必要はないが、実用に足るものを作ることを重視したいので、Bitboardを使う。
    - とりあえず、盤面の占有情報をBitboardで表現することにした。
    - その後、全てのコマの種類についてBitboardを用意した。
    - ※各コマを32bitにして25マスを埋めても表現はできるのだが、ビットシフトによる計算ができなくなるのでBitboardがやはり強い。
    - ここのあたりで、レジスタの命令を使って高速化することをあきらめた。分からないことが多すぎて時間がかかりすぎるのでとりあえずBitboardを用いるなどして高速化できる部分は高速化しつつ、妥協も取り入れることにした。
  - Move
    - Moveは16bitで表現した。
    - とりあえず駒打ちの手、成りの手は考慮していない。
  - Effect
    - 全てのコマについて利きを調査する
      - そのために各コマについて〇〇_effectのような定数を大量に用意する必要がある
      - また、利きを調べるときには、自分のコマの利きと相手のコマの利きを分けて考える必要がある
      - そのために、自分と相手の駒の位置を表すBitboardを用意する必要がある
      - 飛車と角は場のコマ依存なので四方の利きを調べ、専用のビット演算で対処する
  - Movegen
    - 禁じ手（二歩、打ち歩詰め、千日手、隅への歩の打ち込み、不成など）は一度考慮しない。
    - 各ターンごとに、合法手を生成する必要がある。
    - 自分がどちらの手番なのかを判断する（初手で分かる）
      - 初手のpositionコマンドの長さ（6 or 8）で判断した
    1. 自分の手番（BLACK=0、WHITE=1）を考える。今回はWHITEで固定して考える。
    2. 自分の盤上のコマW_GOLDについて、bitboards[W_GOLD]をコピーしてpopし、fromを得る。
    3. fromをgold_effect(from, WHITE)に代入し、利きテーブルgold_effectを得る。
    4. gold_effectをpopしてtoを得る。
    5. fromとtoをmake_move(from,to)関数に代入し、Move型の変数moveを得る。
    6. Moveの配列*move_list にmoveを加える。
    7. 2~6までを全てのコマの種類(W_GOLD, ..., W_DRAGON)まで繰り返す。
  - 不成のランダムな手を選ぶコードが完成した。
  - 合法手の改良
    - 成り、打ちの手（二歩も）Done
    - 王手回避の手
    - 王の自殺手禁止
    - 王を守る駒の移動禁止
    - 隅への打ち込み Done
    - 隅での不成 Done
    - 千日手
    - (取れるなら)相手の玉を取る手
  - リファクタ
    - main関数
      - USI, Bitboards, Positionを初期化
      - USI::loop()を呼び出す
    - Position
      - do_move
        - Moveを受け取る（positionコマンドのsfenはMoveクラスで処理する）
        - 引数をもとに、Bitboardsを更新する
        - StateInfoを更新してポインタをつなげる
      - undo_move
        - StateInfoをさかのぼってBitboardsを更新する
      - StateInfoはとりあえず空のクラスでオッケー
  - 盤面をハッシュ値＋指し手で記録
    - もし同じ盤面が現れたら、その盤面の指し手を返す
  - UCT
  - 2手目まで全探索

# 高速化
### 以下の内容を、後々優先度をつけて実装していく
- 探索の並列化
  - OPENMP?
- shogi.hのenum Pieceをいじくる（forループが少なくて済むようにする）
- 盤面情報を保持したmapを用意し、盤面の情報を更新するときにmapを更新するようにする
  - apply_moveを短縮できるがデータが大きくなるので、メモリが足りなくなる可能性がある
- generate_drop_movesでwhileとifを入れ替える
- ChatGPTに投げてアーキテクチャ依存の高速命令を探す
- pawn_bb[COLOR_NB]などのビットボードを1つに合体し、「黒の歩」は「Occupied[BLACK] & pawn_bb」のように表現する
  - メモリ削減
- moveの中に「捕られる駒」または「動かす駒」の情報を入れ込む
- templateメソッドを用いた高速化
- StateInfoに「この盤面から可能な指し手」を持たせる
  - 指し手生成は高速化するが、メモリが足りなくなる可能性がある
- 利きの差分計算
  - 歩や銀などは、ある駒が移動しても利きはさほど（あるいは全く）変化しないはず
  - 飛車と角は毎回ちゃんと調べる必要がある
    - あるいはrook_effect_bb[SQ]上の駒が動いたとき（あるいはrook_effect_bb[SQ]に駒が乗ってきた時だけ調べてもいいかもしれない） 
    - 利きの枚数は4bitあれば十分。4bit * 25マスなので100bitで表現できる
    - あるいはbitboardを4枚垂直に重ね合わせたもの用意して、独自の計算体系を用意する……？
- 指し手の差分計算
  - 殆どの手は、前ターンと同様の指し手が続くはず
  - 3e3dと動かしたら、3eを目的地にした指し手をリストに追加、3dを目的地とした指し手を削除
  - ↑特にgenerate_dorp_movesで有効そう
  - 3dに移動したコマの指し手を新たに生成
  - moved_pieceみたいな変数を持たせる？
- do_move、undo_moveの高速化
  - 全ての情報を持っているPiece[5][5]の配列を用意する
  - Moveで影響を受ける駒を検出する
  - その駒のBitboardたちと、occupied_bbを更新する
  - 変化したビットだけを反転させるようなビット演算をする
    - 例：1a1bときたら0x11のBitboardを用意して、bb ^= Bitboard(0x11)のような演算をすると速いのでは？
- side_to_move * PIECE_WHITEをビット演算にする
- 利きのハッシュ表
  - rook_effect,bishop_effectが特に遅い
  - all_effectもついでに作る？
    - 「駒の位置」＋「occupied」をキーにしてハッシュ表を作る
    - 正確には「味方の駒の詳細な位置」＋「敵のoccupied」をキーにする

$$
(優先度) = 勝率 + \sqrt{\frac{\log{(総探索回数)}}{この手の探索回数}}
$$
# その他の改良
- 変数iをpcに変更
- 依存関係の整理、ファイルの分割
- 入玉の実装
- for (auto pc : Piece()) ... の実装

# アイデア帳
- MCTSを深さ2でやる
  - 1手目はランダムに選んで2手目はMCTSで選ぶ
  - または、1手目と2手目を全て舐めるようにやる
- ラスト1手の詰みはミスらない
  - 全てのプレイアウトが勝ちになるので…

- 全く別のアプローチ
  - 駒の利きを有向グラフで表す
  - 駒を動かすことは、有向グラフの辺を繋ぎ変える・（敵の駒を取る場合）ノードを狩る、ことに相当する
  - 有向グラフの辺の重みは、その駒の価値に相当する（？）
  - 辺の繋ぎ変えは、動かした駒周辺の辺のみを考えればよい（はず）
    - 飛車や角が動いた時はダルそう
    - その他の駒が動いた時は、effect_bb[PAWN]などからその駒が利いているノードへ接続する

- ノードの使いまわし
  - 計算結果の再利用
  - 要らなくなったノードをfreeしなければならない

- 相手の思考中にもひたすらuctをブン回せば良い気がする（ponder）

- 掘る深さ・探索回数をいじる
  - playoutで３００手まで掘るのは意味がないかもしれない（ただし、そこまで掘らないと序盤の手で優劣がつけづらい）
    - 同じドローでも、駒得などを考慮した値を返すと良いかもしれない
  - 逆に３００手よりも多く掘ることに意味があるかもしれない
  - playoutで掘る深さを浅くして、探索回数を増やすことに意味があるかもしれない

- ランダムプレイのアルゴリズムを改良する
  - 駒損する場所（敵の駒の利き数ー自分の駒の利き数が＞０）にはあまり駒を打たない（10%とかにする）
  - ↑駒打ちならともかく、駒を動かすとなると、動かした前後で利きの枚数が変化するので難しいかもしれない


# レポートメモ
- 可読性を意識した
  - 1年のジョットクのコードの読みづらさ、コメントのなさ…
- 最終目的は「麻雀」
  - MCTSは将棋との相性は悪いが、麻雀との相性は悪くなさそう
  - ランダムプレイの部分をルールベースに変更することでより強化（効率良く探索）できそう